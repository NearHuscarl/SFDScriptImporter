using CSharpMinifier;
using ScriptLinker.Models;
using ScriptLinker.Utilities;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace ScriptLinker.DataLogic
{
    class LineInfo
    {
        public bool StartBlock = false;
        public bool EndBlock = false;
        /// <summary>
        /// Is comment or directive or empty line
        /// </summary>
        public bool IsJunk = false;
    }

    public class Linker
    {
        private readonly string ProjectName = Assembly.GetCallingAssembly().GetName().Name;
        private readonly string BreakpointStatement = "System.Diagnostics.Debugger.Break();";

        private string GetHeader(ScriptInfo info)
        {
            var sb = new StringBuilder();
            var dateNow = DateTime.Now.ToString("HH:mm:ss dd/MM/yyyy");

            sb.AppendLine($"// This file is auto generated by {ProjectName} at {dateNow}");
            sb.AppendLine("// Sauce: https://github.com/NearHuscarl/ScriptLinker");
            sb.AppendLine();
            sb.AppendLine("/*");
            sb.AppendLine($"* author: {info.Author}");
            sb.AppendLine($"* description: {info.Description}");
            sb.AppendLine($"* mapmodes: {info.MapModes}");
            sb.AppendLine("*/");

            return sb.ToString();
        }

        public LinkResult Link(ProjectInfo projectInfo, ScriptInfo scriptInfo, LinkOption option)
        {
            if (!File.Exists(projectInfo.EntryPoint)) return new LinkResult();

            var stopwatch = Stopwatch.StartNew();
            var linkedFiles = new HashSet<string>();
            var usingNamespaces = new HashSet<string>();
            var newNamespaces = new List<string>();
            var sb = new StringBuilder();

            sb.Append(GetHeader(scriptInfo));

            var entryPointInfo = ReadEntryPointFile(projectInfo);

            sb.AppendLine(entryPointInfo.Content);
            linkedFiles.Add(projectInfo.EntryPoint);
            newNamespaces = entryPointInfo.UsingNamespaces
                .Where(ns => ns.StartsWith(projectInfo.RootNamespace))
                .Select(ns => ns.Trim()).ToList();

            while (newNamespaces.Any())
            {
                var addedNamespaces = new List<string>();
                foreach (var file in FileUtil.GetScriptFiles(projectInfo.ProjectDir))
                {
                    if (linkedFiles.Contains(file)) continue;

                    var fileInfo = ReadCSharpFile(projectInfo, file);

                    if (fileInfo.IsEntryPoint)
                    {
                        if (fileInfo.Namespace == entryPointInfo.Namespace
                            && fileInfo.ClassName == entryPointInfo.ClassName
                            && fileInfo.IsPartialClass)
                            fileInfo = ReadEntryPointFile(projectInfo, file);
                        else continue;
                    }

                    if (newNamespaces.Contains(fileInfo.Namespace))
                    {
                        sb.Append(fileInfo.Content);
                        addedNamespaces.AddRange(fileInfo.UsingNamespaces);
                        linkedFiles.Add(file);
                    }
                }

                newNamespaces = addedNamespaces;

                foreach (var newNS in newNamespaces.ToList())
                {
                    if (!usingNamespaces.Contains(newNS) && newNS.StartsWith(projectInfo.RootNamespace))
                        usingNamespaces.Add(newNS.Trim());
                    else
                        newNamespaces.Remove(newNS);
                }
            }

            sb.AppendLine();

            var source = sb.ToString();
            return new LinkResult()
            {
                Content = option.Minified ? Minify(source) : source,
                LinkedFiles = linkedFiles,
                Elapsed = stopwatch.ElapsedMilliseconds,
            };
        }

        private static string Minify(string source)
        {
            return string.Join(null, Minifier.Minify(source));
        }

        private void ReadSharpLine(string line, int codeBlock, ref CSharpFileInfo csFileInfo)
        {
            if (codeBlock <= 1)
            {
                var match = RegexPattern.UsingStatement.Match(line);
                if (match.Success)
                    csFileInfo.UsingNamespaces.Add(match.Groups[1].Value);

                match = RegexPattern.Namespace.Match(line);
                if (match.Success)
                {
                    csFileInfo.Namespace = match.Groups[1].Value;
                    csFileInfo.UsingNamespaces.Add(csFileInfo.Namespace);
                }
            }
            if (string.IsNullOrEmpty(csFileInfo.ClassName))
            {
                var match = RegexPattern.Class.Match(line);
                if (match.Success)
                {
                    csFileInfo.ClassName = match.Groups[3].Value;
                    csFileInfo.IsPartialClass = !string.IsNullOrEmpty(match.Groups[2].Value);
                    csFileInfo.IsEntryPoint = match.Groups[4].Value == "GameScriptInterface";
                }
            }
        }

        private LineInfo GetLineInfo(string line)
        {
            var lineInfo = new LineInfo();
            var commentIndex = line.IndexOf("//"); // -1 if not found

            lineInfo.IsJunk = string.IsNullOrWhiteSpace(line)
                || RegexPattern.Comment.Match(line).Success || RegexPattern.Directive.Match(line).Success;

            if (commentIndex == -1)
                commentIndex = line.Length;

            for (var i = 0; i < line.Length; i++)
            {
                if (i > commentIndex)
                    break;

                if (line[i] == '{') lineInfo.StartBlock = true;
                if (line[i] == '}') lineInfo.EndBlock = true;
            }

            return lineInfo;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="projectInfo"></param>
        /// <param name="filePath">Specify if it's a partial class of the entrypoint class</param>
        /// <returns></returns>
        public CSharpFileInfo ReadEntryPointFile(ProjectInfo projectInfo, string filePath = "")
        {
            if (filePath == "")
            {
                filePath = projectInfo.EntryPoint;
            }

            if (!File.Exists(filePath)) return new CSharpFileInfo();

            var csFileInfo = new CSharpFileInfo();
            var sourceCode = new StringBuilder();
            var breakpoints = projectInfo.Breakpoints
                .Where(b => b.File == filePath)
                .ToDictionary(b => b.LineNumber, b => b);

            using (var file = File.OpenText(filePath))
            {
                var line = "";
                var codeBlock = 0;
                var lineNumber = 1;

                while ((line = file.ReadLine()) != null)
                {
                    ReadSharpLine(line, codeBlock, ref csFileInfo);
                    var lineInfo = GetLineInfo(line);

                    if (lineInfo.IsJunk) continue;
                    if (lineInfo.StartBlock)
                        codeBlock++;

                    if (RegexPattern.Constructor.Match(line).Success)
                    {
                        goto Finish;
                    }

                    if (codeBlock == 2 && !lineInfo.StartBlock && !lineInfo.EndBlock)
                    {
                        sourceCode.AppendLine(line);
                    }
                    if (codeBlock > 2)
                    {
                        sourceCode.AppendLine(line);
                    }
                    if (breakpoints.ContainsKey(lineNumber))
                    {
                        sourceCode.AppendLine(BreakpointStatement);
                    }

                    Finish:
                    if (lineInfo.EndBlock)
                        codeBlock--;

                    lineNumber++;
                }
            }

            csFileInfo.Content = sourceCode.ToString();
            return csFileInfo;
        }

        public CSharpFileInfo ReadCSharpFile(ProjectInfo projectInfo, string filePath)
        {
            if (!File.Exists(filePath)) return new CSharpFileInfo();

            var csFileInfo = new CSharpFileInfo();
            var sourceCode = new StringBuilder();
            var breakpoints = projectInfo.Breakpoints
                .Where(b => b.File == filePath)
                .ToDictionary(b => b.LineNumber, b => b);

            using (var file = File.OpenText(filePath))
            {
                var line = "";
                var codeBlock = 0;
                var lineNumber = 1;

                while ((line = file.ReadLine()) != null)
                {
                    ReadSharpLine(line, codeBlock, ref csFileInfo);
                    var lineInfo = GetLineInfo(line);

                    if (lineInfo.IsJunk) continue;
                    if (lineInfo.StartBlock)
                        codeBlock++;

                    if (codeBlock == 1 && !lineInfo.StartBlock && !lineInfo.EndBlock)
                    {
                        sourceCode.AppendLine(line);
                    }
                    if (codeBlock > 1)
                    {
                        sourceCode.AppendLine(line);
                    }
                    if (breakpoints.ContainsKey(lineNumber))
                    {
                        sourceCode.AppendLine(BreakpointStatement);
                    }

                    if (lineInfo.EndBlock)
                        codeBlock--;

                    lineNumber++;
                }
            }

            csFileInfo.Content = sourceCode.ToString();
            return csFileInfo;
        }
    }
}
